zenithClient:
  iconUrl: https://raw.githubusercontent.com/jupyterhub/binderhub/main/binderhub/static/images/logo_square.png
  description:
  label: "Binderhub"
  auth:
    skip: false

# Use yaml anchors to avoid repetition
registry:
  # This url domain name should match the Service 
  # resource which exposes the local container registry
  url: &registry-url http://binderhub-registry:80
  username: &registry-username testuser
  password: &registry-password testpassword
  nodeport: 31783
  storage:
    capacity: # Set in Azimuth UI

binderhub:
  jupyterhub:
    proxy:
      service:
        # Don't use a Loadbalancer for jupyterhub since 
        # service will sit behind Zenith
        type: ClusterIP
      chp:
        networkPolicy:
          enabled: false
    prePuller:
      hook:
        enabled: false
      continuous:
        enabled: false
    hub:
      config:
        # JupyterHub:
        #   authenticator_class: RemoteUserAuthenticator
        # BinderSpawner:
          # auth_enabled: true
      networkPolicy:
        enabled: false
      # Use mounted ConfigMap instead of extraConfig directly to allow
      # Helm templating into python snippets
      extraVolumes:
      - name: hub-extra-config
        configMap:
          # Note: Name must match ConfigMap in templates/hub-config.yml
          name: hub-extra-config
      extraVolumeMounts:
      - name: hub-extra-config
        mountPath: /usr/local/etc/jupyterhub/jupyterhub_config.d/

      extraConfig:
        customspawner.py: |
          from kubespawner import KubeSpawner

          # Until https://github.com/jupyterhub/kubespawner/issues/498 is fixed
          # https://discourse.jupyter.org/t/advanced-z2jh-deeply-customizing-the-spawner/8432
          class CustomSpawner(BinderSpawnerMixin, LocalRegistryMixin, KubeSpawner):

              def _build_common_labels(self, extra_labels):
                  labels = super()._build_common_labels(extra_labels)
                  label_username = "jupyter-" + labels['hub.jupyter.org/username']
                  labels['hub.jupyter.org/username'] = label_username
                  return labels

          c.KubeSpawner.image_pull_secrets = ["binderhub-registry-image-pull"]
          c.JupyterHub.spawner_class = CustomSpawner

        # Configure the authentication to respect the X-Remote-User header sent by Zenith from Azimuth
        remoteuser.py: |
          from jupyterhub.auth import Authenticator
          from jupyterhub.handlers import BaseHandler

          from tornado import web

          class RemoteUserLoginHandler(BaseHandler):
              def get(self):
                  remote_user = self.request.headers.get("X-Remote-User")
                  if not remote_user:
                      raise web.HTTPError(401)
                  user = self.user_from_username(remote_user)
                  self.set_login_cookie(user)
                  next_url = self.get_next_url(user)
                  self.redirect(next_url)

          class RemoteUserAuthenticator(Authenticator):
              def get_handlers(self, app):
                  return [(r'/login', RemoteUserLoginHandler)]

              async def authenticate(self, *args, **kwargs):
                  raise NotImplementedError()

          c.JupyterHub.authenticator_class = RemoteUserAuthenticator

    singleuser:
      networkPolicy:
        enabled: false
      defaultUrl: /lab
      extraEnv:
        JUPYTERHUB_SINGLEUSER_APP: "jupyter_server.serverapp.ServerApp"
      # TODO: Below is default jupyterhub (but not binderhub) config to
      # enable PVCs for storage, we should do something similar here since
      # binderhub defaults to no persistent storage
      # storage:
      #   type: dynamic
      #   extraLabels: {}
      #   extraVolumes: []
      #   extraVolumeMounts: []
      #   static:
      #     pvcName:
      #     subPath: "{username}"
      #   capacity: 10Gi
      #   homeMountPath: /home/jovyan
      #   dynamic:
      #     storageClass:
      #     pvcNameTemplate: claim-{username}{servername}
      #     volumeNameTemplate: volume-{username}{servername}
      #     storageAccessModes: [ReadWriteOnce]
  
  imageBuilderType: dind
  dind:
    daemonset:
      extraArgs:
        - "--insecure-registry"
        - "binderhub-registry:80"

  # Don't use a Loadbalancer for binderhub since service will sit behind Zenith
  service:
    type: ClusterIP

  # Configure binder to use installed local container registry
  registry:
    url: *registry-url
    username: *registry-username
    password: *registry-password
  
  config:
    BinderHub:
      # Auth is handled by Zenith
      auth_enabled: false
      # Local url should be set explicitly here since (external) 
      # hub_url is overwritten dynamically in extraConfig
      hub_url_local: http://hub:8081/
      use_registry: true
      image_prefix: binderhub-registry:80/azimuth/
    DockerRegistry:
      token_url: None
  
  extraConfig:
    zenith-hub-url.py: |
      # Looks up Zenith FQDN for hub instance on cluster and passes to BinderHub
      # so that we get redirected to correct Zenith url when notebook is ready 
      from kubernetes import client, config
      config.load_incluster_config()
      api = client.CustomObjectsApi()
      current_namespace = open("/var/run/secrets/kubernetes.io/serviceaccount/namespace").read()
      reservations = api.list_namespaced_custom_object(
        'zenith.stackhpc.com', 'v1alpha1', current_namespace, 'reservations'
      )['items']      
      hub_zenith_reservation = list(filter(
        lambda x: '-binderhub-azimuth-jupyterhub' in x['metadata']['name'], reservations
      ))
      if len(hub_zenith_reservation) > 0:
        # Do some error logging here?
        pass
      zenith_url = hub_zenith_reservation[0]['status']['fqdn']
      c.BinderHub.hub_url = f'http://{zenith_url}'