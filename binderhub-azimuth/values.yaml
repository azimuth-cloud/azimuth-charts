zenithClient:
  iconUrl: https://raw.githubusercontent.com/jupyterhub/binderhub/main/binderhub/static/images/logo_square.png
  description:
  label: "Binderhub"

binderhub:
  jupyterhub:

    proxy:
      service:
        # Don't use a Loadbalancer for jupyterhub since service will sit behind Zenith
        type: ClusterIP
      chp:
        networkPolicy:
          enabled: false

    prePuller:
      hook:
        enabled: false
      continuous:
        enabled: false

    hub:
      networkPolicy:
        enabled: false
      extraConfig:
        # Until https://github.com/jupyterhub/kubespawner/issues/498 is fixed
        # https://discourse.jupyter.org/t/advanced-z2jh-deeply-customizing-the-spawner/8432
        customspawner.py: |
          from kubespawner import KubeSpawner

          class CustomSpawner(KubeSpawner):
              def _build_common_labels(self, extra_labels):
                  labels = super()._build_common_labels(extra_labels)
                  label_username = "jupyter-" + labels['hub.jupyter.org/username']
                  labels['hub.jupyter.org/username'] = label_username
                  return labels

          c.JupyterHub.spawner_class = CustomSpawner

        # Configure the authentication to respect the X-Remote-User header sent by Zenith from Azimuth
        remoteuser.py: |
          from jupyterhub.auth import Authenticator
          from jupyterhub.handlers import BaseHandler

          from tornado import web

          class RemoteUserLoginHandler(BaseHandler):
              def get(self):
                  remote_user = self.request.headers.get("X-Remote-User")
                  if not remote_user:
                      raise web.HTTPError(401)
                  user = self.user_from_username(remote_user)
                  self.set_login_cookie(user)
                  next_url = self.get_next_url(user)
                  self.redirect(next_url)

          class RemoteUserAuthenticator(Authenticator):
              def get_handlers(self, app):
                  return [(r'/login', RemoteUserLoginHandler)]

              async def authenticate(self, *args, **kwargs):
                  raise NotImplementedError()

          c.JupyterHub.authenticator_class = RemoteUserAuthenticator
    singleuser:
      networkPolicy:
        enabled: false
      defaultUrl: /lab
      extraEnv:
        JUPYTERHUB_SINGLEUSER_APP: "jupyter_server.serverapp.ServerApp"

  # Use Podman-in-Kubernetes builder since we can't do docker builds directly on host (default behaviour)
  # NOTE: I think this means that we can only ever have a single BinderHub deployment per k8s cluster
  # See https://binderhub.readthedocs.io/en/latest/zero-to-binderhub/setup-binderhub.html#use-podman-inside-kubernetes-pink
  # imageBuilderType: pink
  imageBuilderType: dind

  # Don't use a Loadbalancer for binderhub since service will sit behind Zenith
  service:
    type: ClusterIP

  # Configure binder to use installed local container registry
  registry:
    # This value is also used as the name for the Service resource which exposes the local container registry
    # TODO: Is there a better way to set this value dynamically (e.g. based on namespace, release name etc.)?
    # url: binderhub-registry
    username: "required-but-not-used"
    password: "required-but-not-used"
  config:
    BinderHub:
      use_registry: false
      # image_prefix: binderhub-registry.svc/
    # DockerRegistry:
    #   token_url: "binderhub-registry/v2/token?service="
